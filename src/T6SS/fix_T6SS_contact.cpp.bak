/* ----------------------------------------------------------------------
 LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
 http://lammps.sandia.gov, Sandia National Laboratories
 Steve Plimpton, sjplimp@sandia.gov

 Copyright (2003) Sandia Corporation.  Under the terms of Contract
 DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
 certain rights in this software.  This software is distributed under
 the GNU General Public License.

 See the README file in the top-level LAMMPS directory.
 ------------------------------------------------------------------------- */

#include "fix_T6SS_contact.h"

#include "atom.h"
#include "atom_vec.h"
#include "error.h"
#include "force.h"
#include "group.h"
#include "memory.h"
#include "modify.h"
#include "neigh_list.h"
#include "neighbor.h"
#include "random_park.h"
#include "pair.h"
#include "update.h"
#include <math.h>
#include <string.h>
using namespace LAMMPS_NS;
using namespace FixConst;

/* ---------------------------------------------------------------------- */

FixT6SSContact::FixT6SSContact(LAMMPS *lmp, int narg, char **arg)
    : Fix(lmp, narg, arg),effector_groups(nullptr){
  t6ss_types = nullptr;
  attacker_effectors = nullptr;
  harpoon_lens = nullptr;
  cooldowns = nullptr;
  susceptible_types = nullptr;
  susceptible_effectors = nullptr;
  effector_success_probs = nullptr;
  effector_effects = nullptr;

  if (narg < 4)
    error->all(FLERR, "Illegal fix nufeb/T6SS/contact command");

  // Initialize random number generator, same for all procs
  int seed = utils::inumeric(FLERR, arg[3], true, lmp);
  random = new RanPark(lmp, seed);

  n_t6ss_types = utils::inumeric(FLERR, arg[4], true, lmp);
  if (n_t6ss_types < 0){
      error->all(FLERR, "Specified fewer than 0 T6SS bugs in call to fix/T6SS/contact");
  }
  else {
      printf("%d types of bugs are T6SS capable. Parsing.\n",n_t6ss_types);
  }

  t6ss_types = memory->create(t6ss_types,n_t6ss_types,"fix nufeb/T6SS/contact: t6ss_types");
  attacker_effectors = memory->create(attacker_effectors,n_t6ss_types,"fix nufeb/T6SS/contact: attacker_effectors");
  harpoon_lens = memory->create(harpoon_lens,n_t6ss_types,"fix nufeb/T6SS/contact: harpoon_lens");
  cooldowns = memory->create(cooldowns,n_t6ss_types,"fix nufeb/T6SS/contact: cooldowns");

  int arg_n = 5;
  for(int i = 0; i < n_t6ss_types; i++){
    t6ss_types[i] = utils::inumeric(FLERR, arg[arg_n++], true, lmp);
    attacker_lookup[t6ss_types[i]]=i;
    // TODO validate bug type exists
    printf("Bug %d type code: %d\n",i,t6ss_types[i]);

    //effector id
    attacker_effectors[i] = utils::inumeric(FLERR, arg[arg_n++], true, lmp);
    printf("\t Effector ID: %d\n",attacker_effectors[i]);

    //harpoon length
    harpoon_lens[i] = utils::numeric(FLERR, arg[arg_n++], true, lmp);
    printf("\t harpoonLen: %7g\n",harpoon_lens[i]);

    //cooldown
    cooldowns[i] = utils::inumeric(FLERR, arg[arg_n++], true, lmp);
    printf("\t Cooldown ID: %d\n",cooldowns[i]);
  }

  printf("Bug type %d has attack_index %d\n",4,attacker_lookup[4]);
  printf("Bug type %d has attack_index %d\n",6,attacker_lookup[6]);
  n_susceptible_types = utils::inumeric(FLERR, arg[arg_n++], true, lmp);
  printf("%d types of bugs are susceptible to T6SS effectors. Parsing:\n", n_susceptible_types);

  susceptible_types = memory->create(susceptible_types,n_t6ss_types,"fix nufeb/T6SS/contact: susceptible_types");
  susceptible_effectors = memory->create(susceptible_effectors,n_t6ss_types,"fix nufeb/T6SS/contact: susceptible_effectors");
  effector_success_probs = memory->create(effector_success_probs,n_t6ss_types,"fix nufeb/T6SS/contact: effector_success_probs");
  effector_groups = memory->create(effector_groups,n_t6ss_types,"fix nufeb/T6SS/contact: effector_groups");
  effector_effects = memory->create(effector_effects,n_t6ss_types,"fix nufeb/T6SS/contact: effector_effects");

  for(int i = 0; i < n_susceptible_types; i++){
    susceptible_types[i] = utils::inumeric(FLERR, arg[arg_n++], true, lmp);
    printf("Bug %d type code: %d\n",i,susceptible_types[i]);
    
    //effector id
    susceptible_effectors[i] = utils::inumeric(FLERR, arg[arg_n++], true, lmp);
    printf("\t Effector ID: %d\n",susceptible_effectors[i]);

    //effect probability
    effector_success_probs[i] = utils::numeric(FLERR, arg[arg_n++], true, lmp);
    printf("\t Effect probability: %2g\n",effector_success_probs[i]);

    //effect group
    int toxgroup = -1;
    toxgroup = group->find(arg[arg_n++]);
    toxgroup = 1 | group->bitmask[toxgroup];
    if(toxgroup < 0){
        error->all(FLERR, "Can't find intoxication group.");
    }
    effector_groups[i] = toxgroup;

    //effect type
    effector_effects[i] = utils::inumeric(FLERR, arg[arg_n++], true, lmp);
    printf("\t Effect type: %d\n",effector_effects[i]);

  }
  //TODO sanity check for other args beyond this, could indicate situation
  //where a line defining a bug was added but the n_bugs style param
  //was not updated
}

/* ---------------------------------------------------------------------- */

FixT6SSContact::~FixT6SSContact() {
    delete random;
    memory->destroy(t6ss_types);
    memory->destroy(attacker_effectors);
    memory->destroy(harpoon_lens);
    memory->destroy(cooldowns);
    memory->destroy(susceptible_types);
    memory->destroy(susceptible_effectors);
    memory->destroy(effector_success_probs);
    memory->destroy(effector_groups);
    memory->destroy(effector_effects);
}

/* ---------------------------------------------------------------------- */
void FixT6SSContact::biology_nufeb()
{
    if (update -> ntimestep % nevery) return;
    //printf("T6SS Contact biology step\n");
    do_contact();
    //do_contact_nn();
}

/* ---------------------------------------------------------------------- */

int FixT6SSContact::setmask() {
  int mask = 0;
  mask |= BIOLOGY_NUFEB;
  return mask;
}

void FixT6SSContact::do_contact_nn(){
  int curr_atom_id = -1;

  int *type = atom->type;
  int *mask = atom->mask;
  double *radius = atom->radius;
  double **x = atom->x;

  int n_neigh_lists = list->inum;
  int *curr_neigh_list = list->ilist;
  int *curr_neigh_list_len = list->numneigh;
  int **curr_neigh_list_head = list->firstneigh;

  for(int curr_neigh_list_i = 0; curr_neigh_list_i < n_neigh_lists; curr_neigh_list_i++){
      curr_atom_id = curr_neigh_list[curr_neigh_list_i];
      int num_neighbors = curr_neigh_list_len[curr_atom_id];
      if(num_neighbors <= 0) break;
      //printf("Neighbor List: %d  Current atom: %d\n Neighbors:%d\n",curr_neigh_list_i,curr_atom_id,num_neighbors);
    for(int neigh_i = 0; neigh_i < num_neighbors; neigh_i++){
        //printf("\tNeighbor %d is %d\n",neigh_i,curr_neigh_list[neigh_i] & NEIGHMASK);
        
        // first check if A can attack B
        // We only care if the bug is in the T6SS contact group
        bool is_T6SS = (mask[curr_atom_id] & groupbit);
    
        // Determine if the bug is an attacker
        bool is_attacker = false;
        int attack_index = -1;
        auto lookup = attacker_lookup.find(type[curr_atom_id]);
        is_attacker = lookup != attacker_lookup.end();
        if(is_attacker){
            attack_index = lookup->second;
        }
        
        // terminate if A is not  a T6SS bug and attacking
        if(!(is_T6SS && is_attacker)) break;
       
        // we only care if bug B is NOT the same type AND it is participating in T6SS
        bool same_type = type[neigh_i] == type[curr_atom_id];
        if(same_type) break;

        bool is_v_T6SS = (mask[neigh_i] & groupbit);
        if(!is_v_T6SS) break;
       
        // bug B should also be susceptible to the effector protein of bug A
        bool is_susceptible = false;
        int k_index = -1;
        for(int j = 0; j < n_t6ss_types; j++){
            is_susceptible = is_susceptible || (type[neigh_i] == susceptible_types[j]);
            if(type[neigh_i] == susceptible_types[j]){
               k_index = j;
            }
        }
        //printf("Potential meaningful attack between %d and %d\n",curr_atom_id,neigh_i);
        double dx = x[curr_atom_id][0] - x[neigh_i][0];
        double dy = x[curr_atom_id][1] - x[neigh_i][1];
        double dz = x[curr_atom_id][2] - x[neigh_i][2];
        double krad = radius[neigh_i];
        double irad = radius[curr_atom_id];
        double contact_dist = harpoon_lens[attack_index];
        
        // throw out things where are too are away on any axis
        // may still include stuff on the diagonal which is unreachable, but
        // it's a balance between avoiding trig calls and only testing nearby bugs
        if(!(dx > contact_dist ||
            dy > contact_dist ||
            dz > contact_dist)){   
            // TODO  more efficiently comparing squared distances rather than taking the root
            double dist_between = sqrt(dx * dx + dy * dy + dz * dz) - (irad + krad);
            double a_b_centre_sep = sqrt(dx * dx + dy * dy + dz * dz);
            printf("Centre distance is %.9g. Harpon A has a range of %7g\n",a_b_centre_sep,contact_dist);
         } 
}
    
  }
}

void FixT6SSContact::do_contact() {

  int nlocal = atom->nlocal;
  int *type = atom->type;
  double **x = atom->x;
  double *radius = atom->radius;

  int *mask = atom->mask;

  //keep track of intoxications to apply at the end of all the contact checks
  int *intoxications;
  memory->create(intoxications,nlocal,"fix nufeb/T6SS/contact:intoxications");
  for(int n = 0; n < nlocal; n++){
      intoxications[n] = 0;
  }
  // loop through the neighbor list, finding situations where a T6SS attack
  // bug is within harpoon range of attackable bugs. If so, perform
  // an attack and the susceptible bug responds appropriately.

  // Historic note.  This was originally done by using LAMMPS neighbor lists
  // However there were a few problems
  // 1. At the scales used, getting a neighbor list which included all bugs in
  // range was unreliable.
  // 2. Increasing skin distance or other tricks with force cutoff  sometimes
  // worked, BUT always required tuning and were not obvious when they failed,
  // 3. The various tweaks also greatly increased the number of neighbors in
  // the list, causing large increases in memory usage. Also required adjusting
  // pagenumber and one for neighbor modify - again, case specific. Even then
  // it was not guaranteed that nearer bugs would be included.
  // 4.  The number of neighbors in a  neighborlist which was fairly reliable
  // closely became similar to the number of local bugs total.
  //
  // Conclusion. Until neighbor lists are better understood/more reliable for
  // this purpose we just do the simple loop over all local bugs.  It's been
  // much more reliable, is easier to understand the behaviour, takes far
  // less memory, and doesn't seem to take much longer.  It's technically
  // O(n^2), but the expensive distance calculation only occurs in a fraction
  // of the loop traversals.

  // Find all instances where a T6SS bug is in contact with another bug
  for (int i = 0; i < nlocal; i++) {
    // We only care if the bug is in the T6SS contact group
    bool is_i_T6SS = (mask[i] & groupbit);
    
    // Determine if the bug is an attacker
    // TODO simplify and reduce the number of lookups
    // TODO simplify with continue
    bool is_attacker = false;
    int i_index = -1;
//    if(is_i_T6SS){
//        for(int j = 0; j < n_t6ss_types; j++){
//            is_attacker = is_attacker || (type[i] == t6ss_types[j]);
//            if(type[i] == t6ss_types[j]){
//                i_index = j;
//            }
//        }
//    }
    auto lookup = attacker_lookup.find(type[i]);
    is_attacker = lookup != attacker_lookup.end();
    if(is_attacker){
        i_index = lookup->second;
    }
    // DIAGNOSTIC PRINTF
//    if(is_i_T6SS && is_attacker){
//        printf("iBug %d with type %d is in the T6SS contact group and is an attacker\n",i,type[i]);
//    }
//    if(is_i_T6SS && !is_attacker){
//        printf("iBug %d with type %d is in the T6SS contact group but is NOT an attacker\n",i,type[i]);
//    }
//    if(!is_i_T6SS){
//        printf("iBug %d with type %d is NOT in the T6SS contact group \n",i,type[i]);
//    }
   
    // only need to check neighbors if bug i is participating and an attacker
    //TODO simplify with continue
    if(is_i_T6SS && is_attacker){

        // TODO sort k-indices randomly, avoid biasing attacks towards lower k's
        for (int k = 1 ; k < nlocal; k++) {
            //don't stab ourself
            bool same_bug = k == i;
            // generalization which will usually hold, don't stab kin
            // this would result in no effect anyway, but reduces the 
            // nearest neighbor checks
            // TODO when energetics are involved, we will want to actually
            // stab same kin, since it's still will happen and takes energy
            // NO_STAB_KIN? as a parameter?
            bool same_type = type[k] == type[i];
            bool is_k_T6SS = (mask[k] & groupbit);
            // Determine if the bug is an attacker
            // TODO simplify and reduce the number of lookups
            // TODO simplify with continue
            bool is_susceptible = false;
            int k_index = -1;
            if(is_k_T6SS){
                for(int j = 0; j < n_t6ss_types; j++){
                    is_susceptible = is_susceptible || (type[k] == susceptible_types[j]);
                    if(type[k] == susceptible_types[j]){
                        k_index = j;
                    }
                }
            }
            bool check_contact = !same_bug && !same_type && is_k_T6SS && is_susceptible;

            // only need to check for contact if bug k is in the T6SS contact
            // group and a susceptible bug
            //TODO simplify with continue
            if(check_contact){
                // get x, y, and z distance between bugs and radii of both
                double dx = x[i][0] - x[k][0];
                double dy = x[i][1] - x[k][1];
                double dz = x[i][2] - x[k][2];
                double krad = radius[k];
                double irad = radius[i];
                double contact_dist = 2*harpoon_lens[i_index];
                // throw out things where are too are away on any axis
                // may still include stuff on the diagonal which is unreachable, but
                // it's a balance between avoiding trig calls and only testing nearby bugs
                if(!(dx > contact_dist ||
                   dy > contact_dist ||
                   dz > contact_dist)){   
                    // TODO  more efficiently comparing squared distances rather than taking the root
                    double dist_between = sqrt(dx * dx + dy * dy + dz * dz) - (irad + krad);
                    //TODO this sometimes gives negative values due to irad and krad, double check this isn't a diamter instead of radius.

                    if(i_index < 0){
                        error->all(FLERR, "i_index is less than 0\n");
                    }
                    if (harpoon_lens[i_index]> dist_between) {
                    // printf("A hit, a most palpable hit!\n");
                    // printf("\t iBug %d of type %d hit kBug %d of type %d with a harpoon len of %7g at a distance of %.9g\n",i,type[i],k,type[k],harpoon_lens[i_index],dist_between);
                        if(k_index < 0){
                            error->all(FLERR, "k_index is less than 0\n");
                        }
                        // is the prey susceptible to the attacker's effector?
                        if(attacker_effectors[i_index] == susceptible_effectors[k_index]){
                            //printf("kBug is susceptible to attack\n");
                            double attack_roll = random->uniform();
                            //printf("\tRolled: %f, chance of success: %f\n",attack_roll, effector_success_probs[k_index]);
                            // TODO double check < vs <=
                            if(attack_roll <= effector_success_probs[k_index]){
                                //printf("Attack was successful, should transition to: %d\n",effector_effects[k_index]);
                                //TODO probably better to do this as a bitmask
                                if(intoxications[k] < effector_effects[k_index]){
                                    intoxications[k]=effector_effects[k_index];
                                }
                            }
                        }
                    }
                }                
            }
        }
    }
  }
  //printf("Applying intoxications:\n");
  //TODO instead of looping thru nlocal, intoxications should only hold references to 
  //actually intoxications
  for(int n = 0; n < nlocal; n++){
      if(intoxications[n] != 0){
          //printf("\tBug %d is intoxicated and should shift to state %d.\n",n,intoxications[n]);
          int n_index = -1; 
          for(int j = 0; j < n_t6ss_types; j++){
                if(type[n] == susceptible_types[j]){
                    n_index = j;
                }
            }
          if(n_index == -1){
              error->all(FLERR,"Could not find type index.");
            }
          //should use masking instead of overwriting group mask
          //TODO be smarter about this to improve flexiblity using
          //the difference between lammps types and groups
          //e.g an atom can only be one type but a type may be in
          //many groups
          //things like still being able to stab while intoxicated
          mask[n] = effector_groups[n_index];
          type[n] = intoxications[n];
      }
  } 
  memory->destroy(intoxications);
}

void FixT6SSContact::init_list(int id, NeighList *ptr){
    list = ptr;
}

void FixT6SSContact::init(){
    neighbor->add_request(this,NeighConst::REQ_DEFAULT);
}
